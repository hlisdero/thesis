\documentclass{beamer}
\usepackage{Presentation}

\title[Compile-time Deadlock Detection in Rust]{Compile-time Deadlock Detection \\ in Rust using Petri Nets}
\author{Horacio Lisdero Scaffino}
\institute[FIUBA]{Facultad de IngenierÃ­a\\Universidad de Buenos Aires}
\date{June 30, 2023}
% TWEAK THE FONT SIZE
\setbeamerfont{date}{size=\scriptsize}
% ADD LOGO
\logo{\includegraphics[height=1cm]{FIUBA-Logo.png}}

\AtBeginSection[]
{
  \begin{frame}{Agenda}
  \footnotesize
    \tableofcontents[currentsection]
  \end{frame}
}

\AtBeginSubsection[]
{
  \begin{frame}{Agenda}
  \footnotesize
    \tableofcontents[currentsection, currentsubsection]
  \end{frame}
}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

% REMOVE THE LOGO FROM NOW ON %
\logo{}

\begin{frame}{Agenda}
  \tableofcontents
\end{frame}

\section{Introduction}

\section{Rust}

\subsection{What is Rust?}

\begin{frame}{What is Rust?}
  Rust is a multi-paradigm, general-purpose programming language that
  aims to provide developers with a safe and efficient way to write low-level code.

  \pause
  \vfill

  \begin{itemize}
    \item Memory-safe
    \item Compiled to machine code, no runtime needed
    \item High-level simplicity
    \item Low-level performance (on the same level as C or C++)
  \end{itemize}
\end{frame}

\begin{frame}{Brief timeline of Rust}
  \begin{description}
    \item [2007] Started as a side project by Graydon Hoare, a programmer at Mozilla
    \item [2009] Mozilla officially started sponsoring the project
    \item [2015] First stable version 1.0
    \item [2016] Mozilla releases Servo, a browser engine built with Rust
    \item [2019] \texttt{async/await} support stabilized
    \item [2021] The Rust Foundation is founded by AWS, Huawei, Google, Microsoft, and Mozilla
    \item [2021] The Android Open Source Project encourages the use of Rust for the SO components below the ART
    \item [2022] The Linux kernel adds support for Rust alongside C
    \item [2023] 8 years in a row the most loved programming language in the Stack Overflow Developer Survey
  \end{description}
\end{frame}

\begin{frame}{Memory safety}
  It achieves memory safety without using a garbage collector or reference counting.
  Instead, it uses the concept of \textbf{ownership} and \textbf{borrowing}.

  \vfill
  \pause

  It prevents a wide variety of error classes at compile-time:

  \begin{itemize}
    \item Double free
    \item Use after free
    \item Dangling pointers
    \item Data races
    \item Passing non-thread-safe variables
  \end{itemize}

  \vfill

  If a violation of the compiler rules is found, the program will simply not compile.
\end{frame}

\subsection{How does it look like?}

\begin{frame}[fragile]{Immutability by default}
  \begin{listing}
    \begin{minted}{Rust}
      fn main() {
        let x = 1;
        x = x + 1;
      }
    \end{minted}
  \end{listing}

  \vfill

  \begin{listing}
    \scriptsize
    \begin{Verbatim}[commandchars=\\\{\}]
      \textbf{\textcolor{red}{error[E0384]}: cannot assign twice to immutable variable `x`}
      --> src/main.rs:3:5
      |
    2 |     let x = 1;
      |         \textcolor{blue}{-}
      |         \textcolor{blue}{|}
      |         \textcolor{blue}{first assignment to `x`}
      |         \textcolor{blue}{help: consider making this binding mutable: `mut x`}
    3 |     x = x + 1;
      |     \textcolor{red}{^^^^^^^^^ cannot assign twice to immutable variable}
    \end{Verbatim}
  \end{listing}
\end{frame}

\begin{frame}[fragile]{Move semantics by default}
  Each value has only one owner.
  If a variable is passed to another function or scope, the owner of the value changes.

  \vfill

  \begin{listing}
    \begin{minted}{Rust}
      fn main() {
        let name = String::from("Alice");
        print_name(name);
        println!("The name is: {}", name); // Compilation error
      }
    
      fn print_name(name: String) {
          println!("Name: {}", name);
      }
    \end{minted}
  \end{listing}
\end{frame}

\begin{frame}[fragile]{Algebraic Data Types, aka enums with fields}
  \begin{listing}
    \begin{minted}[fontsize=\tiny, frame=none]{Rust}
      enum Shape {
        Circle { radius: f64 },
        Rectangle { width: f64, height: f64 },
        Triangle { base: f64, height: f64 },
      }
    
      fn main() {
          let shapes = vec![
              Shape::Circle { radius: 5.0 },
              Shape::Rectangle { width: 10.0, height: 8.0 },
              Shape::Triangle { base: 7.0, height: 4.0 },
          ];
      
          for shape in shapes {
              match shape {
                  Shape::Circle { radius } => {
                      let circle = Circle { radius };
                      // Do something with the circle...
                  },
                  Shape::Rectangle { width, height } => {
                      let rectangle = Rectangle { width, height };
                      // Do something with the rectangle...
                  },
                  Shape::Triangle { base, height } => {
                      let triangle = Triangle { base, height };
                      // Do something with the triangle...
                  },
              }
          }
      }
    \end{minted}
  \end{listing}
\end{frame}

\subsection{Why Rust?}

\section{Petri nets}

\subsection{Examples}

\section{Translation}

\subsection{MIR}

\subsection{Modelling threads}

\subsection{Modelling mutexes}

\subsection{Modelling condition variables}

\begin{frame}{Bibliography}
  \tiny
  \bibliographystyle{apalike}
  \bibliography{
    ../Bibliography/Articles.bib,
    ../Bibliography/Blogs.bib,
    ../Bibliography/Books.bib,
    ../Bibliography/Conferences.bib,
    ../Bibliography/Proceedings.bib
  }
\end{frame}

\end{document}
