\section{Bibliotecas de redes de Petri en Rust}

Como parte del desarrollo de la traducción del código fuente a una red de Petri, es necesario
utilizar una biblioteca de redes de Petri para el lenguaje de programación Rust. Una búsqueda
rápida de los paquetes disponibles en \emph{crates.io}\footnote{\url{https://crates.io/}},
GitHub y GitLab reveló que, por desgracia, no existe ninguna biblioteca bien mantenida.

Se encontraron algunos simuladores de redes de Petri como:

\begin{itemize}
      \item pns\footnote{\url{https://gitlab.com/porky11/pns}}:
            Programado en C. No ofrece la opción de exportar la red resultante a un formato
            estándar.
      \item PetriSim\footnote{\url{https://staff.um.edu.mt/jskl1/petrisim/index.html}}:
            Un antiguo simulador DOS/PC programado en Bordland Pascal.
      \item WOLFGANG\footnote{\url{https://github.com/iig-uni-freiburg/WOLFGANG}}:
            Un editor de redes de Petri en Java, mantenido por el Departamento de
            Informática de la Universidad de Friburgo, Alemania.
\end{itemize}

Desafortunadamente ninguno de ellos cumple los requisitos de la tarea.

Considerando que una red de Petri es un grafo, se evaluó la posibilidad de utilizar una biblioteca de
grafos y modificarla para adaptarla a los objetivos de este trabajo. Se encontraron dos
bibliotecas de grafos en Rust:

\begin{itemize}
      \item petgraph\footnote{\url{https://docs.rs/petgraph/latest/petgraph/}}:
            La biblioteca más utilizada para gráficos en \textit{crates.io}. Ofrece una opción para
            exportar al formato DOT.
      \item gamma\footnote{\url{https://github.com/metamolecular/gamma}}:
            Inestable y sin cambios desde 2021. No ofrece la posibilidad de exportar el gráfico.
\end{itemize}

Ninguna de las posibilidades satisface el requisito de exportar la red resultante al formato
\acrshort{PNML}. Además, si se utiliza una biblioteca de grafos, las operaciones de una red de Petri
deben implementarse como un \emph{wrapper} alrededor de un grafo, lo que reduce la posibilidad
de optimizaciones para nuestro caso de uso y dificulta la extensibilidad a largo plazo del
proyecto.

En conclusión, es imperativo implementar una biblioteca de redes de Petri en Rust desde cero
como un proyecto independiente. Esto aporta una herramienta más a la comunidad que podría
reutilizarse en el futuro.