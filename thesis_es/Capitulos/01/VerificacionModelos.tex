\section{Verificaci√≥n de modelos}

Model checking is a technique used in software development
to formally verify the correctness of a system's behavior
with respect to its specifications or requirements.
It involves constructing a mathematical model of the system
and analyzing it to ensure that it meets certain properties,
such as mutual exclusion when accessing shared resources,
absence of data races and deadlock-freedom.

The process of model checking begins by constructing a finite-state model of the system,
typically using a formal language, in the case of this work the language of Petri nets.
The model captures the system's behavior and the properties that are to be verified.
The next step is to perform an exhaustive search of the state space of the model
to ensure that all possible behaviors have been considered.
This search can be performed automatically using specialized software tools.

During the search, the model checker looks for counterexamples,
which are sequences of events that violate the system's specifications.
If a counterexample is found, the model checker provides information
on the state of the system at the time of the violation,
helping developers to identify and fix the problem.

Model checking has become a widely-applied technique
in the development of critical software systems,
such as aerospace \cite{carreno2005safety,monzon2009deadlock}
and automotive control systems \cite{Perronnet2019},
medical devices, and financial systems.
By verifying the correctness of the software before it is deployed,
developers can ensure that the system meets its requirements and is safe to use.

One of the main advantages of model checking is
that it provides a formal and rigorous approach to verifying software correctness.
Unlike traditional testing methods, which can only demonstrate the presence of errors,
model checking can prove the absence of errors.
This is particularly relevant for safety-critical systems like the ones mentioned before,
where a single error can have catastrophic consequences for human lives.
Model checking can also be automated, allowing developers to quickly
and efficiently verify the correctness of complex software systems.
This reduces the time and cost of software development
and increases confidence in the correctness of the system.

It is known that formal software verification tools are currently applied
in a few very specific fields where
formal proof of the correctness of the system is required.
\cite{reid:hatra:2020} discusses the importance of bringing verification
tools closer to developers through an approach
that seeks to maximize the cost-benefit ratio of its use.
Improvements in the usability of existing tools and
approaches to incorporate their use into the developer's routine are presented.
The paper starts from the premise that from the developer's point of view,
verification can be seen as a different type of unit or integration test.
Therefore, it is of utmost importance that running the verification is as easy as possible
and feedback is provided to the developer promptly during the development process
to increase adoption.

The main conclusion from this section is
that model checking could bring substantial improvements
to the table in terms of increased safety and reliability of software systems.
These objectives align with the goals of
the Rust programming language and the goals of this work.
Detecting deadlocks and missed signals in the source code at compile time could
help developers prevent hard-to-find bugs and get quick feedback on the correct use
of synchronization primitives, saving time and thus money in the development process.
One particular goal of this work is
to make the tool user-friendly and easy to get started with
so that its adoption benefits the larger community of Rust developers.