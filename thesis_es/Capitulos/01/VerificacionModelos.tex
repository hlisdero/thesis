\section{Verificación de modelos}

La comprobación de modelos es una técnica utilizada en el desarrollo de software para verificar
formalmente la correctitud del comportamiento de un sistema con respecto a sus
especificaciones o requisitos. Consiste en construir un modelo matemático del sistema y
analizarlo para garantizar que cumple ciertas propiedades, como la exclusión mutua al acceder
a recursos compartidos, la ausencia de carreras de datos (\textit{data races}) y la ausencia de deadlocks.

El proceso de comprobación de modelos comienza construyendo un modelo de estado finito
del sistema, típicamente utilizando un lenguaje formal, en el caso de este trabajo el lenguaje de
las redes de Petri. El modelo captura el comportamiento del sistema y las propiedades que
deben verificarse. El siguiente paso es realizar una búsqueda exhaustiva del espacio de estados
del modelo para asegurarse de que se han considerado todos los comportamientos posibles.
Esta búsqueda puede realizarse automáticamente utilizando herramientas de software
especializadas.

Durante la búsqueda, el verificador de modelos busca contraejemplos, es decir secuencias de
eventos que violen las especificaciones del sistema. Si se encuentra un contraejemplo, el
verificador de modelos proporciona información sobre el estado del sistema en el momento de
la violación, lo que ayuda a los desarrolladores a identificar y solucionar el problema.

La comprobación de modelos se ha convertido en una técnica ampliamente aplicada en el
desarrollo de sistemas de software críticos, como los dispositivos médicos,
los sistemas financieros y de control aeroespacial
\cite{carreno2005safety,monzon2009deadlock} y de automóviles \cite{Perronnet2019}.
Al verificar la correctitud del software antes de su despliegue,
los desarrolladores pueden garantizar que el sistema cumple sus requisitos y es seguro de usar.

Una de las principales ventajas de la comprobación de modelos es que proporciona un enfoque
formal y riguroso para verificar la correctitud del software. A diferencia de los métodos de
prueba (test) tradicionales, que sólo pueden demostrar la presencia de errores, la comprobación de
modelos puede demostrar la ausencia de errores. Esto es especialmente relevante para sistemas
de seguridad crítica como los mencionados anteriormente en los que un solo error puede tener
consecuencias catastróficas para vidas humanas. La comprobación de modelos también puede
automatizarse, lo que permite a los desarrolladores verificar de forma rápida y eficaz la
correctitud de sistemas de software complejos. Esto reduce el tiempo y el coste del desarrollo de
software y aumenta la confianza en el sistema.

Se sabe que las herramientas formales de verificación de software se aplican actualmente en
unos pocos campos muy específicos en los que se requiere una demostración formal de la correctitud
del sistema. \cite{reid:hatra:2020} habla de la importancia de acercar las herramientas de
verificación a los desarrolladores mediante un enfoque que busque maximizar la relación coste-
beneficio de su uso. Se presentan mejoras en la usabilidad de las herramientas existentes y
enfoques para incorporar su uso a la rutina del desarrollador. El paper parte de la premisa
de que, desde el punto de vista del desarrollador, la verificación puede verse como un tipo
diferente de prueba unitaria o de integración. Por lo tanto, es de suma importancia que la
ejecución de la verificación sea lo más sencilla posible y que se proporcione retroalimentación (feedback)
al desarrollador con rapidez durante el proceso de desarrollo para aumentar su adopción.

La principal conclusión de esta sección es que la comprobación de modelos podría aportar
mejoras sustanciales en términos de mayor seguridad y fiabilidad de los sistemas de software.
Estos objetivos se alinean con las metas del lenguaje de programación Rust y los objetivos de
este trabajo. Detectar los bloqueos y las señales perdidas en el código fuente en tiempo de
compilación podría ayudar a los desarrolladores a evitar errores difíciles de encontrar y a
obtener feedback rápidamente sobre el uso correcto de las primitivas de sincronización, ahorrando
tiempo y, además, dinero en el proceso de desarrollo. Un objetivo concreto de este trabajo es
hacer que la herramienta sea fácil de usar y de empezar a utilizar, de modo que su adopción
beneficie a la comunidad entera de desarrolladores de Rust.