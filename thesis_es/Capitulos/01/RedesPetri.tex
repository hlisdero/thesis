\section{Redes de Petri}

\subsection{Visión general}

Las redes de Petri (\acrfull{PN}) son una herramienta de modelado gráfico y matemático utilizada para
describir y analizar el comportamiento de los sistemas concurrentes. Fueron introducidas por el
investigador alemán Carl Adam Petri en su tesis doctoral \cite{petri1962} y desde entonces se han aplicado en diversos
campos como la informática, la ingeniería y la biología. Puede encontrar un resumen conciso
de la teoría de las redes de Petri, sus propiedades, análisis y aplicaciones en \cite{murata1989}.

Una red de Petri es un grafo dirigido bipartito formado por un conjunto de lugares, transiciones
y arcos. Hay dos tipos de nodos: lugares y transiciones. Los lugares representan el estado del
sistema, mientras que las transiciones representan eventos o acciones que pueden ocurrir. Los
arcos conectan lugares a transiciones o transiciones a lugares. No puede haber arcos entre
dos lugares o entre dos transiciones, preservando así la propiedad bipartita.

Los lugares pueden contener cero o más marcas o fichas. Los tokens se utilizan para representar la
presencia o ausencia de entidades en el sistema, como recursos, datos o procesos. En la clase
más simple de redes de Petri, los tokens no llevan ninguna información y son indistinguibles
unos de otros. El número de fichas en un lugar o la simple presencia de una ficha es lo que
transmite significado en la red. Las fichas se consumen y se producen al dispararse las
transiciones, lo que da la impresión de que se mueven a través de los arcos.

En la representación gráfica convencional, los lugares se representan mediante círculos,
mientras que las transiciones se representan como rectángulos. Las fichas se representan como
puntos negros dentro de los lugares, como se ve en la Fig. \ref{fig:petri-net-example}.

\begin{figure}[!htb]
      \centering
      \includesvg[width=0.9\linewidth]{petri-net-example.svg}
      \caption{Ejemplo de una red de Petri. \uppercase{PLACE 1} contiene una marca.}
      \label{fig:petri-net-example}
\end{figure}

Cuando una transición se dispara, consume fichas de sus lugares de entrada y produce fichas en
sus lugares de salida, lo que refleja un cambio en el estado del sistema. El disparo de una
transición se activa cuando hay suficientes fichas en sus lugares de entrada.
En la Fig. \ref{fig:petri-net-transition-example},
podemos ver cómo se producen los disparos uno detrás del otro.

\begin{figure}[!htb]
      \centering
      \includesvg[width=0.9\linewidth]{petri-net-transition-example.svg}
      \caption{Ejemplo de disparo de una transición:
            La transición 1 se dispara primero, luego se dispara la transición 2.}
      \label{fig:petri-net-transition-example}
\end{figure}

El disparo de las transiciones habilitadas no es determinista, es decir, se disparan
aleatoriamente mientras estén habilitadas.
Una transición deshabilitada se considera \emph{muerta} si
no hay ningún estado alcanzable en el sistema que pueda llevar a que la transición se habilite.
Si todas las transiciones de la red están muertas, entonces la red también se considera \emph{muerta}.
Este estado es análogo al bloqueo (\textit{deadlock}) de un programa informático.

Las redes de Petri pueden utilizarse para modelar y analizar una amplia gama de sistemas,
desde sistemas sencillos con unos pocos componentes hasta sistemas complejos con muchos
componentes que interactúan entre sí. Pueden utilizarse para detectar problemas posibles en
un sistema, optimizar su rendimiento y diseñar e implementar sistemas de forma más eficaz.

También pueden utilizarse para modelar procesos industriales \cite{aalst1994putting}, para
validar requisitos de software expresados como casos de uso \cite{silva2004applying} o para
especificar y analizar sistemas en tiempo real \cite{kavi1996specification}.

En concreto, las redes de Petri pueden utilizarse para detectar deadlocks en el código fuente
modelando el programa de entrada como una red de Petri y analizando después la estructura de
la red resultante. Se demostrará que este enfoque es formalmente sólido y practicable para el
código fuente escrito en el lenguaje de programación Rust.

\subsection{Modelo matemático formal}

Una red de Petri es un tipo particular de grafo bipartito, con pesos y dirigido, dotado de un
estado inicial denominado \emph{marcado inicial}, $M_0$.
Para este trabajo, se utilizará la siguiente
definición general de una red de Petri tomada de \cite{murata1989}.

\begin{definition}{Petri net}{petri-net}
      Una red de Petri es una 5-tupla, $ PN = (P, T, F, W, M_{0}) $ donde:

      \begin{quote}
            $ P = \{ p_1, p_2, \dots, p_m \} $ es un conjunto finito de lugares,\\
            $ T = \{ t_1, t_2, \dots, t_n \} $ es un conjunto finito de transiciones,\\
            $ F \subseteq (P \times T) \cup (T \times P) $ es un conjunto de arcos (relación de flujo),\\
            $ W: F \leftarrow \{1, 2, 3, ... \} $ es una función de peso para los arcos,\\
            $ M_{0}: P \leftarrow \{0, 1, 2, 3, .... \} $ es el marcado inicial,\\
            $ P \cap T = \varnothing $ y $ P \cup T \neq \varnothing $
      \end{quote}
\end{definition}

En la representación gráfica, los arcos se etiquetan con su peso que es un número entero no
negativo $k$. Normalmente el peso se omite si es igual a 1. Un arco con peso $k$ puede
interpretarse como un conjunto de $k$ arcos paralelos distintos.

Un \emph{marcado (estado)} asocia a cada lugar un número entero no negativo $l$.
Si un marcado asigna al lugar $p$ un número entero no negativo $l$,
decimos que $p$ está \emph{marcado con $l$ marcas o tokens}.
Pictóricamente, denotamos esto colocando $l$ puntos negros (fichas) en el lugar $p$.
El \emph{p-ésimo} componente de $M$, denotado por $M(p)$, es el número de fichas en el lugar $p$.

Una definición alternativa de las redes de Petri utiliza un multiconjunto (\emph{bag}) en lugar de un conjunto para
definir los arcos, permitiendo así la presencia de múltiples elementos. Puede encontrarse en la
literatura, por ejemplo, \cite[Definition 2.3]{peterson1981}.

Como ejemplo, consideremos la red de Petri $ PN_{1} = (P, T, F, W, M) $ donde:

\begin{quote}
      $ P = \{ p_1, p_2 \} $,\\
      $ T = \{ t_1, t_2 \} $,\\
      $ F = \{ (p_1, t_1), (p_2, t_2), (t_1, p_2), (t_2, p_2) \} $,\\
      $ W(a_i) = 1 \quad \forall a_i \in F $\\
      $ M(p_1) = 0, M(p_2) = 0 $
\end{quote}

Esta red no contiene fichas y todos los pesos de los arcos son iguales a 1.
Se muestra en la Fig. \ref{fig:petri-net-formal-example}.

\begin{figure}[!htb]
      \centering
      \includegraphics[scale=0.50]{petri-net-formal-example.png}
      \caption{Example of a small Petri net containing a self-loop.}
      \label{fig:petri-net-formal-example}
\end{figure}

La Fig. \ref{fig:petri-net-formal-example}
contiene una estructura interesante que encontraremos más adelante.
Esto motiva la siguiente definición.

\begin{definition}{Bucle}{self-loop}
      Un lugar $p$ y una transición $t$ definen un bucle si
      $p$ es a la vez un lugar de entrada y un lugar de salida de $t$.
\end{definition}

En la mayoría de los casos, nos interesan las redes de Petri que no contienen bucles
las cuales se denominan \emph{puras}.

\begin{definition}{Red de Petri pura}{pure-petri-net}
      Se dice que una red de Petri es pura si no tiene bucles.
\end{definition}

Además, si el peso de cada arco es igual a uno, llamamos a la red de Petri \emph{ordinaria}.

\begin{definition}{Red de Petri ordinaria}{ordinary-petri-net}
      Se dice que una red de Petri es ordinaria si todos los pesos de sus arcos son 1, es decir,
      \begin{equation*}
            W(a) = 1 \quad \forall a \in F
      \end{equation*}
\end{definition}

\subsection{Disparo de transiciones}
\label{sec:transition-firing}

La regla de disparo de transición es el concepto central de las redes de Petri. A pesar de ser
aparentemente simple, sus implicaciones son de gran alcance y complejidad.

\begin{definition}{Regla de disparo de transiciones}{transition-firing-rule}
      Sea $ PN = (P, T, F, W, M_{0}) $ una red de Petri.
      \begin{enumerate}[label=(\roman*)]
            \item Se dice que una transición $t$ está habilitada si cada lugar de entrada $p$ de $t$
                  marcado con al menos $W(p, t)$ marcas
                  donde $W(p,t)$ es el peso del arco que va de $p$ de $t$.
            \item Una transición activada puede dispararse o no, dependiendo de si el evento tiene
                  lugar o no.
            \item El disparo de una transición activada $t$ elimina
                  $W(t,p)$ marcas de cada lugar de entrada $p$ de $t$
                  donde $W(t, p)$ es el peso del arco de $t$ a $p$.
      \end{enumerate}
\end{definition}

Siempre que se habiliten varias transiciones para un marcado $M$ dado, puede dispararse
cualquiera de ellas. La elección es no determinista. Se dice que dos transiciones habilitadas
están en \emph{conflicto} si el disparo de una de ellas inhabilita la otra transición.
En este caso, las transiciones compiten por la ficha colocada en un lugar de entrada compartido.

Si dos transiciones $t_1$ y $t_2$ están habilitadas en algún marcado pero no están en conflicto, pueden
dispararse en cualquier orden, es decir, $t_1$ luego $t_2$ o $t_2$ luego $t_1$.
Tales transiciones representan eventos que pueden ocurrir concurrentemente o en paralelo.
En este sentido, el modelo de red de Petri adopta un modelo de paralelismo basado en el intercalado (\emph{interleaved model of parallelism}),
es decir, el comportamiento del sistema es el resultado de un intercalado arbitrario de los eventos paralelos.

Las transiciones sin lugares de entrada ni lugares de salida reciben un nombre especial.

\begin{definition}{Transición fuente (\textit{Source transition})}{source-transition}
      Una transición sin ningún lugar de entrada se denomina transición fuente.
\end{definition}

\begin{definition}{Transición sumidero (\textit{Sink transition})}{sink-transition}
      Una transición sin lugar de salida se denomina transición de sumidero.
\end{definition}

Cabe destacar que una transición fuente se activa incondicionalmente y produce fichas sin
consumir ninguna, mientras que el disparo de una transición sumidero consume fichas sin
producir ninguna.

\subsection{Simuladores en línea}

Para familiarizarse con la dinámica de las redes de Petri, resulta útil simular algunos ejemplos
en línea, ya que ver una red de Petri en acción es más claro que cualquier explicación estática
sobre el papel. Hemos reunido algunas herramientas con este fin para aliviar la carga del lector.

\begin{itemize}
      \item Puede encontrar un sencillo simulador hecho por Igor Kim en \url{https://petri.hp102.ru/}.
            La herramienta incluye un vídeo tutorial en Youtube y redes de ejemplo.
      \item Como complemento, el profesor Wil van der Aalst de la Universidad de Hamburgo ha
            elaborado una serie de tutoriales interactivos. Estos tutoriales son archivos de Adobe
            Flash Player (con extensión
            \texttt{.swf}) que los navegadores web modernos no pueden ejecutar.
            Por suerte, se puede
            utilizar un emulador Flash en línea como el que se encuentra en \url{https://flashplayer.fullstacks.net/?kind=Flash_Emulator}
            para cargar los archivos
            y ejecutarlos.
      \item Otro editor y simulador de redes de Petri en línea es \url{http://www.biregal.com/}.
            El usuario puede dibujar la red, añadir los tokens y luego disparar manualmente las
            transiciones.
\end{itemize}

\subsection{Ejemplos de modelado}

En esta subsección, se presentan varios ejemplos sencillos para introducir algunos conceptos
básicos de las redes de Petri que son útiles en el modelado. Esta subsección se ha adaptado de
\cite{murata1989}.

Para otros ejemplos de modelado, como el problema de exclusión mutua, los semáforos
propuestos por Edsger W. Dijkstra, el problema del productor/consumidor y el problema de los
filósofos cenando, se remite al lector a \cite[Chap. 3]{peterson1981} y \cite{reisig2013}.

\subsubsection{Máquinas de estado finito}

Las máquinas de estados finitos (\acrfull{FSM}) pueden representarse mediante una subclase de redes de Petri.

Como ejemplo de máquina de estado finito, consideremos una máquina expendedora de café.
Acepta monedas de \EUR{1} o \EUR{2} euros y vende dos tipos de café, el primero cuesta \EUR{3} euros y el
segundo \EUR{4} euros.
Supongamos que la máquina puede contener hasta \EUR{4} y no devuelve ningún cambio.
Entonces, el diagrama de estados
de la máquina puede representarse mediante la red de Petri
que se muestra en la Fig. \ref{fig:state-machine-example}.

\begin{figure}[!htb]
      \centering
      \includesvg[width=\linewidth]{state-machine-example.svg}
      \caption{La red de Petri para una máquina expendedora de café,
            es equivalente a un diagrama de estados.}
      \label{fig:state-machine-example}
\end{figure}

Las transiciones representan la inserción de una moneda del valor etiquetado, por ejemplo,
``Insert \EUR{1} coin''. Los lugares representan un posible estado de la máquina, es
decir, la cantidad de dinero almacenada actualmente en su interior. El lugar situado más a la
izquierda, etiquetado ``\EUR{0}'', está marcado con una ficha y corresponde al estado inicial del
sistema.

Ahora podemos presentar la siguiente definición de esta subclase de redes de Petri.

\begin{definition}{Máquinas de estado}{state-machines}
      Una red de Petri en la que cada transición tiene exactamente un arco entrante y
      exactamente un arco saliente se conoce como máquina de estados.

      Cualquier \acrshort{FSM} (o su diagrama de estados) puede modelarse con una máquina de estados.
\end{definition}

La estructura de un lugar $p_1$ que tiene dos (o más) transiciones de salida $t_1$ y $t_2$ se denomina
conflicto, decisión o elección, según la aplicación en cuestión.
Esto se ve en el lugar inicial de la Fig. \ref{fig:state-machine-example},
donde el usuario debe seleccionar qué moneda introducir al principio.

\subsubsection{Actividades en paralelo}

Contrary to finite-state machines, Petri nets can also model parallel or concurrent activities.
In Fig. \ref{fig:parallel-activities-example} an example of this is shown,
where the net represents the division of a bigger task
into two subtasks that may be executed in parallel.

\begin{figure}[!htb]
      \centering
      \includesvg[width=0.8\linewidth]{parallel-activities-example.svg}
      \caption{The Petri net depicting two parallel activities in a fork-join fashion.}
      \label{fig:parallel-activities-example}
\end{figure}

The transition ``Fork'' will fire before ``Task 1'' and ``Task 2''
and that ``Join'' will only fire after both tasks are complete.
But note that the order in which ``Tast 1'' and ``Tast 2'' execute is non-deterministic.
``Task 1'' could fire before, after, or at the same time that ``Task 2''.
It is precisely this property of the firing rule in Petri nets
that allows the modeling of concurrent systems.

\begin{definition}{Concurrency in Petri nets}{petri-net-concurrency}
      Two transitions are said to be concurrent if they are causally independent, i.e.,
      the firing of one transition does not cause and is not triggered by the firing of the other.
\end{definition}

Note that each place in the net in Fig. \ref{fig:parallel-activities-example}
has exactly one incoming arc and one outgoing arc.
This subclass of Petri nets allows the representation of concurrency but not decisions (conflicts).

\begin{definition}{Marked graphs}{marked-graphs}
      A Petri net in which each place has exactly one incoming arc
      and exactly one outgoing arc is known as a marked graph.
\end{definition}

\subsubsection{Protocolos de comunicación}

Communications protocols can also be represented in Petri nets.
Fig. \ref{fig:communication-protocols-example} illustrates a simple protocol
in which Process 1 sends messages to Process 2 and
waits for an acknowledgment to be received before continuing.
Both processes communicate through a buffered channel whose maximum capacity is one message.
Therefore, only one message may be traveling between the processes at any given time.
For simplicity, no timeout mechanism was included.

\begin{figure}[!htbp]
      \centering
      \includesvg[width=\linewidth]{communication-protocols-example.svg}
      \caption{A simplified Petri net model of a communication protocol.}
      \label{fig:communication-protocols-example}
\end{figure}

A timeout for the send operation could be incorporated into the model
by adding a transition $t_{timeout}$ with edges from ``Wait for ACK'' to ``Ready to send''.
This maps the decision between receiving the acknowledgment and the timeout.

\subsubsection{Control de sincronización}

In a multithreaded system, resources and information are shared among several threads.
This sharing must be controlled or synchronized
to ensure the correct operation of the overall system.
Petri nets have been used to model a variety of synchronization mechanisms,
including the mutual exclusion, readers-writers, and producers-consumers problems \cite{murata1989}.

A Petri net for a readers-writers system with $k$ processes
is shown in Fig. \ref{fig:readers-writers-example}.
Each token represents a process and the choice of T1 or T2
represents whether the process performs a read or a write operation.

It makes use of weighted edges to remove atomically
$k - 1$ tokens from P3 before performing a write (transition T2),
thus preventing readers from entering the right loop of the net.

At most $k$ processes may be reading at the same same,
but when one process is reading, no process is allowed to read, that is P2 will be empty.
It can be easily verified that the mutual exclusion property is satisfied for the system.

\begin{figure}[!htbp]
      \centering
      \includesvg[width=\linewidth]{readers-writers-example.svg}
      \caption{A Petri net system with k processes that either read or write.}
      \label{fig:readers-writers-example}
\end{figure}

It should be pointed out that this system is not free from starvation,
since there is no guarantee that a write operation will eventually take place.
The system is on the other hand free from deadlocks.

\subsection{Propiedades importantes}

In this subsection, we will look at fundamental concepts for the analysis of Petri nets
that will facilitate the understanding of the nets we will be dealing with in the rest of the work.

\subsubsection{Alcanzabilidad}
\label{sec:reachability}

Reachability is one of the most important questions
when studying the dynamic properties of a system.
The firing of enabled transitions causes changes in the location of the tokens.
In other words, it changes the marking $M$.
A sequence of firings creates a sequence of markings
where each marking may be denoted as a vector of length $n$,
with $n$ being the number of places in the Petri net.

A \emph{firing} or \emph{occurence sequence} is denoted by
$ \sigma = M_0\; t_1\; M_1\; t_2\; M_2\; \cdots\; t_l\; M_l$ or simply
$ \sigma = t_1\; t_2\; \cdots\; t_l\; $, since the markings
resulting from each firing are derived
from the transition firing rule described in Sec. \ref{sec:transition-firing}.

\begin{definition}{Reachability}{reachability}
      We say that a marking $M$ is reachable from $M_0$
      if there exists a firing sequence $\sigma$ such that $M$ is contained in $\sigma$.
\end{definition}

The set of all possible markings reachable from $M_0$ is denoted by $R(N, M_0)$ or more simply
$R(M_0)$ when the net meant is clear.
This set is called the \emph{reachability set}.

A problem of utmost importance in the theory of Petri nets can be presented then,
namely the \emph{reachability problem}:
Finding if $M_n \in R(M_0, N)$ for a given net and initial marking.

In some applications, we are just interested in the markings of a subset of places
and we can ignore the remaining ones.
This leads to a variation of the problem known as the \emph{submarking reachability problem}.

It has been shown that the reachability problem is decidable \cite{mayr1981}.
Nevertheless, it was also shown that it takes exponential space
(formally, it is EXPSPACE-hard) \cite{lipton1976}.
New methods have been proposed to make the algorithms more efficient \cite{kungas2005petri}.
Recently, \cite{czerwinski2020reachability} improved
the lower bound and showed that the problem is not ELEMENTARY.
These results highlight that the reachability problem is still
an active area of research in theoretical computer science.

For this and other key problems, the most important theoretical results
obtained up to 1998 are detailed in \cite{esparza1994decidability}.

\subsubsection{Acotamiento y seguridad}

During the execution of a Petri net, tokens may accumulate in some places.
Applications need to ensure that the number of tokens in a given place does not
exceed a certain tolerance.
For example, if a place represents a buffer,
we are interested that the buffer will never overflow.

\begin{definition}{Boundedness}{boundedness}
      A place in a Petri net is k-bounded or k-safe
      if the number of tokens in that place cannot exceed a finite integer $k$
      for any marking reachable from $M_0$.

      A Petri net is k-bounded or simply bounded if all places are bounded.
\end{definition}

Safeness is a special case of boundedness.
It applies when the place contains either 1 or 0 tokens during execution.

\begin{definition}{Safeness}{safeness}
      A place in a Petri net is safe if the number of tokens in that place never exceeds one.

      A Petri net is safe if each place in that net is safe.
\end{definition}

The nets in Fig. \ref{fig:state-machine-example}, \ref{fig:parallel-activities-example}
and \ref{fig:communication-protocols-example} are all safe.

The net in Fig. \ref{fig:readers-writers-example}
is k-bounded because all its places are k-bounded.

\subsubsection{Liveness}

The concept of liveness is analogous to
the complete absence of deadlocks in computer programs.

\begin{definition}{Liveness}{liveness}
      A Patri net $(N, M_0)$ is said to be live
      (or equivalently $M_0$ is said to be a live marking for N) if,
      for every marking reachable from $M_0$, it is possible to fire any transition
      of the net by progressing through some firing sequence.
\end{definition}

When a net is live, it can always continue executing,
no matter the transitions that fired before.
Eventually, every transition can be fired again.
If a transition can be fired only once and there is no way to enable it again,
then the net is not live.

This is equivalent to saying that the Petri net is \emph{deadlock-free}.
Let us now define what constitutes a deadlock and show examples of it.

\begin{definition}{Deadlock in Petri nets}{petri-net-deadlock}
      A deadlock in a Patri net is a transition (or a set of transitions) that cannot fire
      for any marking reachable from $M_0$.
      The transition (or a set of transitions) cannot become enabled again
      after a certain point in the execution.
\end{definition}

A transition is \emph{live} if it is not deadlocked.
If a transition is live, it is always possible to pick a suitable firing
to get from the current marking to a marking that enables the transition.

The nets in Fig. \ref{fig:state-machine-example}, \ref{fig:parallel-activities-example}
and \ref{fig:communication-protocols-example} are all live.
In all these cases, after some firings,
the net returns to the initial state and can restart the cycle.

The net in Fig. \ref{fig:petri-net-example} is not live.
After two firings it finishes executing and nothing more can happen.
The net in Fig. \ref{fig:petri-net-formal-example} is also not live, because
T1 will only execute once and only T2 can be enabled from that point on.

\subsection{Análisis de alcanzabilidad}

Having introduced the reachability set $R(N, M_0)$ in Sec. \ref{sec:reachability},
we can now present a major analysis technique for Petri nets: the \emph{reachability tree}.

We will run the algorithm for constructing the reachability tree step by step
and then present its advantages and drawbacks.
In general terms, the reachability tree has the following structure:
Nodes represent markings generated from $M_0$, the root of the tree, and its successors.
Each arc represents a transition firing, which transforms one marking into another.

\begin{figure}[!htb]
      \centering
      \includesvg[width=0.5\linewidth]{reachability-tree-example.svg}
      \caption{A marked Petri net for illustrating the construction of a reachability tree.}
      \label{fig:reachability-tree-example}
\end{figure}

Consider the Petri net shown in Fig. \ref{fig:reachability-tree-example}.
The initial marking is $(1, 0, 0)$.
In this initial marking, two transitions are enabled: T1 and T3.
Given that we would like to obtain the entire reachability set,
we define a new node in the reachability tree for each reachable marking,
which results from firing each transition.
An arc, labeled by the transition fired, leads from the initial marking
(the root of the tree) to each of the new markings.
After this first step (Fig. \ref{fig:reachability-tree-step-1}),
the tree contains all markings that are immediately reachable from the initial marking.

\begin{figure}[!htb]
      \centering
      \includesvg[width=0.5\linewidth]{reachability-tree-step-1.svg}
      \caption{The first step building the reachability tree
            for the Petri net in Fig. \ref{fig:reachability-tree-example}.}
      \label{fig:reachability-tree-step-1}
\end{figure}

Now we must consider all markings reachable from the leaves of the tree.

From marking $(0,0,1)$ we cannot fire any transition.
This is known as a \emph{dead marking}.
In other words, it is a ``dead-end'' node.
This class of end-states is particularly relevant for deadlock analysis.

From the marking on the right of the tree, denoted $(1, 1, 0)$, we can fire T1 or T3.
If we fire T1, we obtain $(0, 1, 1)$ and if T3 fires, the resulting marking is $(1, 2, 0)$.
This produces the tree of Fig. \ref{fig:reachability-tree-step-2}.

\begin{figure}[!htb]
      \centering
      \includesvg[width=0.7\linewidth]{reachability-tree-step-2.svg}
      \caption{The second step building the reachability tree
            for the Petri net in Fig. \ref{fig:reachability-tree-example}.}
      \label{fig:reachability-tree-step-2}
\end{figure}

Note that starting with marking $(0, 1, 1)$, only the transition T2 is enabled,
which will lead to a marking $(0, 0, 1)$ that was already seen before.
If instead we take $(1, 2, 0)$ we have again the same possibilities as starting from $(1, 1, 0)$.
It is easy to see that the tree will continue to grow down that path.
The tree is therefore infinite and this is because
the net in Fig. \ref{fig:reachability-tree-example} is not bounded.
See Fig. \ref{fig:reachability-tree-final-step} for the abbreviated final result.

\begin{figure}[!htb]
      \centering
      \includesvg[width=\linewidth]{reachability-tree-final-step.svg}
      \caption{The infinite reachability tree for the Petri net in Fig.
            \ref{fig:reachability-tree-example}.}
      \label{fig:reachability-tree-final-step}
\end{figure}

The previously presented method enumerates the elements in the reachability set.
Every marking in the reachability set will be produced
and so for any Petri net with an infinite reachability set,
i.e., an infinite number of possible states,
the corresponding tree would also be infinite.
Nonetheless, this opposite is not true.
A Petri net with a finite reachability set can have an infinite tree
(see Fig. \ref{fig:reachability-tree-bounded-net-counterexample}).
This net is even \emph{safe}.
In conclusion, dealing with a bounded or safe net is not
a guarantee that the total number of reachable states will be finite.

\begin{figure}[!htb]
      \centering
      \includesvg[width=0.9\linewidth]{reachability-tree-bounded-net-counterexample.svg}
      \caption{A simple Petri net with an infinite reachability tree.}
      \label{fig:reachability-tree-bounded-net-counterexample}
\end{figure}

For the reachability tree to be a useful analysis tool,
it is necessary to devise a method to limit it to a finite size.
This implies in general a certain loss of information since the method will have to map
an infinite number of reachable markings onto a single element.
The reduction to a finite representation may be accomplished by the following means.

Notice on one hand that we may encounter duplicate nodes
in our tree and we always naively treat them as new.
This is illustrated most clearly in Fig. \ref{fig:reachability-tree-bounded-net-counterexample}.
It is thus possible to stop the exploration of the successors of a duplicated node.

Notice on the other hand that some markings are strictly different from previously seen markings
but they enable the same set of transitions.
We say in this case that the marking with additional tokens \emph{covers} the one
that has the minimum number of tokens needed to enable the set of transitions in question.
Firing some transitions may allow us to accumulate an arbitrary number of tokens in one place.
For example, firing T3 in the Petri net seen in
Fig. \ref{fig:reachability-tree-example} exhibits exactly this behavior.
Therefore, it would suffice to mark the accumulating place
with a special label $\omega$, which stands for infinity
since we could get as many tokens as we wish in that place.

For instance, the result of converting the tree of Fig. \ref{fig:reachability-tree-final-step}
to a finite tree is shown in Fig. \ref{fig:reachability-tree-final-step-finite}.

\begin{figure}[!htb]
      \centering
      \includesvg[width=0.7\linewidth]{reachability-tree-final-step-finite.svg}
      \caption{The finite reachability tree for the Petri net in Fig.
            \ref{fig:reachability-tree-example}.}
      \label{fig:reachability-tree-final-step-finite}
\end{figure}

For more details about

\begin{enumerate}
      \item the technique for representing infinite reachability trees using $\omega$,
      \item a definition of the algorithm and precise steps for constructing the reachability tree,
      \item mathematical proof that the reachability tree generated by it is finite,
      \item and the distinction between the reachability tree and the \emph{reachability graph}
\end{enumerate}

the reader is referred to \cite{murata1989} and \cite{peterson1981}.
These concepts are beyond the scope of this work
and are not required in the following chapters.