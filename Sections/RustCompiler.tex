% !TeX root = ../Thesis.tex
\documentclass[../Thesis.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}

\begin{document}

\section{Rust compiler: \emph{rustc}}

The Rust compiler, rustc, is responsible for translating Rust code into executable code.
However, rustc is not a traditional compiler in the sense
that it performs multiple passes over the code,
as described in Sec. \ref{sec:compiler-architecture}.
Instead, rustc is built on a query-based system that supports incremental compilation.

In rustc's query system, the compiler computes a dependency graph between code artifacts,
including source files, crates, and intermediate artifacts, such as object files.
The query system then uses this graph to efficiently recompile
only those artifacts that have changed since the last
compilation\footnote{\url{https://rustc-dev-guide.rust-lang.org/queries/incremental-compilation.html}}.
This incremental compilation can significantly
reduce the compilation time for large projects,
making it easier to develop and iterate on Rust code.

The query system also enables rustc to perform other optimizations,
such as memoization and caching of intermediate results.
For example, if a function's return value has been computed before,
the query system can return the cached result instead of recomputing it,
further reducing compilation time.

Another important design choice in rustc is interning.
Interning is a technique to store strings and
other data structures in a memory-efficient way.
Instead of storing multiple copies of the same string or data structure,
rustc stores only one copy in a special allocator called an \emph{arena}.
References to values stored in the arena are passed around between different parts
of the compiler and they can be compared cheaply by comparing pointers.
This can reduce memory usage and speed up operations
that compare or manipulate strings and data structures.

rustc uses the LLVM compiler infrastructure\footnote{\url{https://llvm.org/}}
to perform low-level code generation and optimization.
LLVM provides a flexible framework for compiling code
to a variety of targets, including native machine code and \acrfull{WASM}.
Rustc uses LLVM to optimize code for performance and
to generate high-quality code for a variety of platforms.
Instead of generating machine code, rustc only needs
to generate the source code's LLVM \acrfull{IR}
and then instruct LLVM to transform this to the compilation target,
applying the desired optimizations.

rustc is programmed in Rust.
In order to compile the newer version of the compiler
and the newer standard library version that goes with it,
a slightly older version of rustc and the standard library is used.
This process is called \emph{bootstraping} and it implies
that one of the major users of Rust is the Rust compiler itself.
Considering that a new stable version of rustc is released every six weeks,
bootstraping involves a substantial amount of complexity and is described
in detail in the documentation\footnote{\url{https://rustc-dev-guide.rust-lang.org/building/bootstrapping.html}}
and in conferences \cite{nelson2022} and tutorials \cite{klock2022} by members of the Rust team.

\subsection{Compilation stages}

The existence of the query system does not imply
that rustc does not have compilation phases at all.
On the contrary, several stages of compilation are required
to transform Rust source code into machine code that can be executed on a computer.
These stages involve multiple intermediate representations of the program,
each one optimized for a specific purpose.
We will now briefly describe these stages.
A more complete overview is found
in the documentation\footnote{\url{https://rustc-dev-guide.rust-lang.org/overview.html}}.

\subsubsection{Lexing and parsing}

First, the raw Rust source text is analyzed by a low-level lexer.
At this stage, the source text is turned
into a stream of atomic source code units known as tokens.

Then parsing takes place.
The stream of tokens is converted into an AST.
Interning of string values occurs here.
Macro expansion, AST validation, name resolution,
and early linting also take place during this stage.
The resulting intermediate representation from this step is thus the AST.

\subsubsection{HIR lowering}

Next, the AST is converted to \acrfull{HIR}.
This process is known as ``lowering''.
This representation looks like Rust code but with complex constructs desugared
to simpler versions.
For instance, all \texttt{while} and \texttt{for} loops are converted into simpler
\texttt{loop} loops.

The HIR is used to perform some important steps:

\begin{enumerate}
      \item \emph{type inference}: The automatic detection of a type
            of an expression, e.g. when declaring variables with \texttt{let}.
      \item \emph{trait solving}: Ensuring that each implementation block (\texttt{impl})
            refers to a valid, existing trait.
      \item \emph{type checking}: This process converts the types written by the user
            into the internal representation used by the compiler.
            It is, in other words, where types are interned.
            Then, using this information, the type safety, correctness, and coherence are verified.
\end{enumerate}

\subsubsection{MIR lowering}

In this stage, the HIR is lowered to \acrfull{MIR},
which is used for \emph{borrow checking}.
As part of the process, the \acrfull{THIR} is constructed,
which is a representation that is easier to convert to MIR than the HIR.

The THIR is an even more desugared version of HIR.
It is used for pattern and exhaustiveness matching.
It is similar to the HIR, but with all types and method calls made explicit.
Furthermore, implicit dereferences are included where needed.

Many optimizations are performed on the MIR
as it is still a very generic representation.
Optimizations are in some cases easier
to perform on the MIR than on the subsequent LLVM IR.

\subsubsection{Code generation}

This is the last stage when producing a binary.
It includes the call to LLVM for code generation
and the corresponding optimizations.
To this effect, the MIR is converted to LLVM IR.

LLVM IR is the standard form of input for the LLVM compiler
that all compilers using LLVM, such as clang C compiler, utilize.
It is a type of assembly language that is well-annotated
and designed to be easy for other compilers to produce.
Additionally, it is designed to be rich enough to enable LLVM
to perform several optimizations on it.

LLVM transforms the LLVM IR to machine code
and applies many more optimizations.
Finally, the object files with assembly code in them may be
linked together to form the binary.

\end{document}