\section{Condition variable (\texttt{std::sync::Condvar})}

A condition variable is a synchronization primitive used in concurrent programming
to enable threads to wait for a certain condition
to become true before proceeding with their execution.
Threads block and wait until they are notified by another thread
that the desired condition has been met.
Condition variables are typically associated with a mutex,
which ensures exclusive access to the shared data that the condition depends on.
When a thread waits on a condition variable, it releases the associated mutex,
allowing other threads to make progress.
When the condition becomes true or some event occurs,
a notifying thread signals the condition variable,
allowing one or more waiting threads to resume their execution.

The semantics of condition variables, as well as examples in pseudocode,
were introduced in Sec. \ref{sec:condition-variables}.
The understanding of the precise behavior of condition variables in all circumstances
is a prerequisite for this section.

This section provides an elaborate explanation of the \acrshort{PN} model
used to represent condition variables from the Rust standard library.
It is followed by a practical example that aims to enhance the clarity of the concepts.
Finally, the algorithms for the translation of condition variable functions are outlined.

\subsection{Petri net model}

In this particular case, the \acrshort{PN} model must be examined carefully,
as it involves not only the condition variable itself
but also the variable that holds the condition
on which the blocked thread is waiting and the mutex
that synchronizes access to that condition.

This interaction can be extremely complex in general.
For instance, the same condition variable could be used
to signal an arbitrary number of distinct conditions.
Accordingly, different mutexes may be passed as an argument to the call to \Rustinline{wait}.
Furthermore, an arbitrary number of threads may wait on a condition variable and
Rust supports the broadcast operation to awaken all waiting threads at once
through the method \Rustinline{notify_all}\footnote{\url{https://doc.rust-lang.org/std/sync/struct.Condvar.html\#method.notify_all}}
(see Sec. \ref{sec:condition-variables}).
Most importantly, the condition itself could be of any type
and could take a long sequence of values during the execution,
depending on which the waiting threads could act in diverse ways for every scenario.

For the above reasons, it is unavoidable to make assumptions
regarding the usage of condition variables that we aim to support
in order to reduce the complexity of the task.
Embracing and dealing with every possibility is beyond the scope of this thesis.

\subsubsection{Assumptions}

\begin{enumerate}
      \item \emph{Single call}: There is only one call to \Rustinline{wait} per condition variable, i.e.,
            \Rustinline{condvar.wait()} appears in a single place in the code for a given \Rustinline{condvar}.
            For example, it can be inside of a loop but it cannot be in two different functions.
      \item \emph{Single-element queue}: There is at most one waiting thread per condition variable.
      \item \emph{Boolean condition}: The condition is a boolean flag. It is either set or not set.
            Waiting on a condition that may take 3 or more values is \emph{not} supported by this model.
      \item \emph{Mandatory set-condition / No ``false notify''}: If a thread locks the mutex and accesses the shared condition mutably,
            then it always sets it to a different value.
            In simpler terms, threads that look at the value, do not change it
            and immediately after notify the condition variable are not supported.
      \item \emph{Broadcast exclusion}: The method \Rustinline{std::sync::Condvar::notify_all} is out of scope.
\end{enumerate}

Support for multiple calls to \Rustinline{wait} and multiple waiting threads could be implemented
but a considerable implementation effort is required.
Alternatively, assumptions 1 and 2 can be overcome with the proposed model.

Supporting non-boolean conditions
and detecting when the value is set and when it is not
necessitates a thorough reconsideration of the modeling approach
for representing specific data values in simple Petri nets.
Consequently, assumptions 3 and 4 are particularly challenging and
could be the subject of future research into higher-lever models
See Sec. \ref{sec:future-work-higher-level-models} for some thoughts to this effect.

\subsubsection{Analysis of the proposed model}

Fig. \ref{fig:condition-variable-model} depicts
the \acrshort{PN} model used in the implementation.
The same diagram in DOT and SVG format
can be found in the repository as documentation.

\begin{figure}[!htbp]
      \centering
      \includesvg[width=\linewidth]{condition-variable-model.svg}
      \caption{The Petri net model for condition variables.}
      \label{fig:condition-variable-model}
\end{figure}

\subsubsection{Table of possible inputs and expected outputs}

As a complement to the explanation in the previous subsection,
here is a table summarizing the expected output for a given input.

\begin{table}[h!]\
      \centering
      \begin{tabular}{ |c|c|c|c|l| }
            \hline
            Row \# & \multicolumn{3}{|c|}{Input} & Output                                                                                                            \\
            \hline
                   & \Rustinline{condition_set}  & \Rustinline{wait_enabled} & \Rustinline{notify} & \emph{where the initial token at \Rustinline{input} ends}       \\
            \hline
            R1     & False                       & False                     & False               & \Rustinline{waiting} (waiting for a \Rustinline{notify})        \\
            R2     & False                       & False                     & True                & \Rustinline{output} (correct wait end condition)                \\
            R3     & False                       & True                      & False               & \Rustinline{input} (initial state)                              \\
            R4     & False                       & True                      & True                & \emph{lost signal (transient state, goes to R1)}                \\
            R5     & True                        & False                     & False               & \Rustinline{waiting} (condition set, needs \Rustinline{notify}) \\
            R6     & True                        & False                     & True                & \Rustinline{waiting} (correct wait end condition)               \\
            R7     & True                        & True                      & False               & \Rustinline{output} (skip the wait)                             \\
            R8     & True                        & True                      & True                & \Rustinline{output} (skip the wait, with lost signal)           \\
            \hline
      \end{tabular}
      \caption{A summary of the possible states of the Petri net model for condition variables.}
      \label{table:condition-variable-model-states}
\end{table}

\subsection{A practical example}

\subsection{Algorithms for condition variable translation}
\label{sec:condvar-algorithms}

To wrap up this section, we will present a concise summary
of the algorithms utilized in the translation of condition variables.
The additions required to the mutex algorithms are included afterward as well.

When a call to \Rustinline{std::sync::Condvar::new} is encountered:

\begin{enumerate}
      \item Translate the function call using the model seen in Fig. \ref{fig:function-with-cleanup}.
      \item Create a new \Rustinline{Condvar}\footnote{\url{https://github.com/hlisdero/cargo-check-deadlock/blob/main/src/translator/sync/condvar.rs}}
            structure with an index to identify it unequivocally across the \acrshort{PN}.
      \item Link the return value of \Rustinline{std::sync::Condvar::new},
            the new condition variable, to the \Rustinline{Condvar} structure.
\end{enumerate}

When a call to \Rustinline{std::sync::Condvar::notify_one} is encountered:

\begin{enumerate}
      \item Translate the function call using the model seen in Fig. \ref{fig:simplest-function}.
            Ignore the cleanup place because, otherwise, any call may fail,
            which amounts to the notify operation not being present in the program,
            leading to a false lost signal.
            This is equivalent to assuming that the \Rustinline{notify_one} function never fails.
      \item Retrieve the \Rustinline{self} reference to the condition variable
            on which the function is called.
      \item Add an arc from the transition representing the function call
            to the \Rustinline{notify} place of the underlying condition variable.
\end{enumerate}

When a call to \Rustinline{std::sync::Condvar::wait}
or \Rustinline{std::sync::Condvar::wait_while} is encountered:

\begin{enumerate}
      \item Ignore the cleanup place because, otherwise, any call may fail,
            which amounts to the wait operation not being present in the program,
            leading to an incorrect result.
            We must force the \acrshort{PN}
            to ``wait'' for the notifying signal to be sent.
            This is equivalent to assuming that the \Rustinline{wait}
            or \Rustinline{wait_while} function never fails.
      \item Retrieve the \Rustinline{self} reference to the condition variable
            on which the function is called.
      \item Extract the mutex guard passed into the function.
      \item Connect the start and end place to the
            \Rustinline{wait_start} and \Rustinline{notify_received} transitions respectively.
      \item Link the return value, the same mutex guard that was passed as an argument,
            to the \Rustinline{MutexGuard} structure.
      \item Notify the translator that the mutex received must be linked to this \Rustinline{Condvar}.
            For this purpose, use the enum variant \Rustinline{PostprocessingTask::LinkMutexToCondvar}.
            This task will be processed after translating all the threads.
\end{enumerate}

When all the threads finished translating, that is,
when the queue of threads to process is empty,
the \Rustinline{Translator} enters a loop
to complete the postprocessing tasks by priority order:

\begin{enumerate}
      \item Create at the beginning of the loop an empty vector of mutex references.
      \item Pop from the \Rustinline{std::collections::BinaryHeap} the task with the lowest priority.
            This will be by design a \Rustinline{PostprocessingTask::NewMutex}.
            Add the mutex reference to the vector.
      \item After processing all the lower priority tasks,
            the \Rustinline{Translator} has references to all the mutexes in the code.
            Continue popping tasks from the priority queue.
      \item Eventually, a \Rustinline{PostprocessingTask::LinkMutexToCondvar} is extracted.
            Link each mutex to the condition variable,
            which creates the places \Rustinline{condition_set}
            and \Rustinline{condition_not_set} for the condition.
            It also connects the \Rustinline{deref_mut} transitions
            to these places to set the condition.
            Lastly, it connects the condition places to the condition variable transitions
            to disable the \Rustinline{wait}.
\end{enumerate}

\subsubsection{Modifications to the mutex algorithms}

As stated before, the mutex algorithms require some additions to successfully
perform missed signal detection.

Add the following to the handler of the \Rustinline{std::sync::Mutex::new} function:

\begin{enumerate}
      \item Notify the translator that a new mutex has been created.
            For this purpose, use the enum variant \Rustinline{PostprocessingTask::NewMutex}.
            This task will be processed after translating all the threads.
\end{enumerate}

When a call to \Rustinline{std::result::Result::<T, E>::unwrap} is encountered:

\begin{enumerate}
      \item Check that the \Rustinline{self} reference is a mutex or a mutex guard.
      \item Translate the function call using the model seen in Fig. \ref{fig:simplest-function}.
            Ignore the cleanup place because, otherwise, any call may fail,
            as if the mutex lock operation
            were not present in the program, leading to a false lost signal.
            This is equivalent to assuming that the \Rustinline{unwrap} function never fails
            when applied to a variable linked to a mutex or a mutex guard.
\end{enumerate}

When a call to \Rustinline{std::ops::Deref::deref}
or \Rustinline{std::ops::DerefMut::deref_mut} is encountered:

\begin{enumerate}
      \item Check that the \Rustinline{self} reference is a mutex or a mutex guard.
      \item Translate the function call using the model seen in Fig. \ref{fig:simplest-function}.
            Ignore the cleanup place because, otherwise, any call may fail,
            as if the mutex lock operation
            were not present in the program, leading to a false lost signal.
            This is equivalent to assuming that the \Rustinline{deref}
            and \Rustinline{deref_mut} functions never fail
            when dereferencing a variable linked to a mutex or a mutex guard.
      \item If the value is being dereferenced mutably (\Rustinline{deref_mut}),
            extract the first argument passed to the function: The mutex or mutex guard.
            Add the \Rustinline{deref_mut} transition to the mutex
            to set the condition for a condition variable in the postprocessing step.
      \item Otherwise do nothing.
            The immutable case does not need to be added to the mutex.
\end{enumerate}

It should now be clear to the reader that the algorithms for missed signal detection are
fundamentally of higher complexity and ought to handle more border cases than
those for detecting simple deadlocks caused by incorrect usage of mutexes or
calling \Rustinline{join} on threads that never terminate.

It is worth mentioning that some border cases arise
due to the inclusion of the cleanup logic
from the \acrshort{MIR} in the \acrshort{PN} model.
If the implementation instead skipped this,
under the hypothesis that Rust standard library functions may never panic,
then the algorithms would become simpler.
Sec. \ref{sec:future-work-no-cleanup} is concerned with
the question of not modeling the cleanup paths.