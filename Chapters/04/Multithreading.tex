\section{Multithreading}

Multithreading support is a prerequisite for deadlock and missed signal detection.
In order to support real-world programs
where deadlocks or missed signals are possible in the first place,
it becomes essential to support having several threads that share resources.
First, the basics will be presented to later devise a \acrshort{PN} model that captures
the behavior of threads in Rust code.

\subsection{Thread lifetime in Rust}

The lifetime of a thread begins when it is started by invoking the
\Rustinline{std::thread::spawn}\footnote{\url{https://doc.rust-lang.org/std/thread/fn.spawn.html}}
function.
It receives a closure or function as an argument,
representing the code that the new thread will execute concurrently
with the other threads of the program.
The spawned thread may start running immediately after it is spawned
but there is no guarantee that it will do so.

Contrary to other programming languages like C, C++ or Java,
Rust does not have the notion of a thread variable
initialized previously to the start of the thread.
Instead, the function \Rustinline{std::thread::spawn} returns
a \Rustinline{std::thread::JoinHandle},
which is, as the name suggests, a handle to call \Rustinline{join}
at the end of the thread's lifetime.

During its existence, a thread can independently execute its designated code
and perform various operations concurrently with other threads.
It can access shared resources and communicate with other threads
through synchronization mechanisms like
mutexes, condition variables, channels, or atomic operations.
This enables concurrent processing and parallelism in Rust programs.

To ensure proper coordination between threads,
Rust provides a mechanism to join threads.
The \Rustinline{std::thread::JoinHandle::join}\footnote{\url{https://doc.rust-lang.org/std/thread/struct.JoinHandle.html\#method.join}} method
allows the main thread or another thread
to wait for the completion of a different thread.
By calling join on a join handle,
the calling thread blocks until the spawned thread finishes its execution.
Once a thread completes its execution and is joined by another thread,
its lifetime ends, and the corresponding system resources are released.
Otherwise, threads that were not joined correctly may potentially leak resources.

If the join handle is dropped, the thread may no longer be joined and it implicitly becomes \emph{detached}.
A detached thread refers to a thread without a valid join handle
and will continue its execution independently until it completes or the program terminates.
They are useful in scenarios where the spawning thread
does not need to wait for the thread to complete its task.
For example, in long-running background tasks or
when the main thread terminates independently of the detached thread's progress.
However, it's important to stress that
the execution of detached threads may continue \emph{even} after the main thread exited.

\subsection{Petri net model for a thread}

To incorporate additional threads into the \acrshort{PN} model,
a distinct subnet is appended to the main net to represent each thread.
This subnet encapsulates the execution path of the newly spawned thread
and operates as an isolated context.
It establishes precise interfaces that connect back to the main net.
The closure provided to the \Rustinline{spawn} function, being a MIR function,
can invoke other functions that in turn require translation.
Therefore, processing a thread's function follows
a similar approach to the usual translation logic.

The concurrency aspect of the execution of the new thread is modeled by the generation
of a new token at the transition that represents the call to \Rustinline{spawn}.
This token can be interpreted, in the same manner as the token in \Rustinline{PROGRAM_START},
as the instruction counter of the new thread.
Essentially, the spawn operation constitutes a ``fork'' in the token flow:
One token enters the transition and two tokens exit from it.
The first proceeds along the main thread's path to execute the subsequent statement,
while the second is directed to the first \acrshort{BB} of the function passed to the thread.

Each thread identified in the source code possesses designated start and end places
labeled \Rustinline{THREAD_<index>_START} and \Rustinline{THREAD_<index>_END}, respectively.
The index is mandatory to preserve the label uniqueness property across the entire program.
It should be emphasized that
this mimics the basic places for the program detailed in Sec. \ref{sec:basic-places}.

Threads lack a separate panic place
as invoking \Rustinline{panic!()} inside a thread
only terminates that specific thread's execution.
We are not interested in differentiating between thread end states;
the main requirement is to determine whether a thread is finished or not.
A single end place for both cases suffices here.

The joining behavior serves as the inverse operation of the spawn.
The transition corresponding to the \Rustinline{join} call consumes two tokens
but generates only one token.
As a result, the waiting condition is straightforward:
The main thread can continue, i.e, the \Rustinline{join} transition can fire,
if and only if the thread to be joined has finished execution,
reaching its respective \Rustinline{THREAD_END} place.

To recapitulate, the thread is translated to a separate subnet
that interfaces with the main net only at three places:

\begin{itemize}
  \item The \Rustinline{spawn} transition where the thread starts.
  \item The (optional) \Rustinline{join} transition where the join handle is utilized.
  \item The connections due to synchronization variables, analyzed in Sec. \ref{sec:sync-primitives}.
\end{itemize}
