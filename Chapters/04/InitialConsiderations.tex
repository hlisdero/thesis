\section{Initial considerations}

\subsection{Basic places of a Rust program}
\label{sec:basic-places}

The basic Petri net model for a Rust program generated by the tool
can be seen in Fig. \ref{fig:program-places}.
The place labeled \Rustinline{PROGRAM_START} contains a token
and represents the initial state of the Rust program.
This token will ``move'' from statement to statement
and can thus be interpreted as the program counter of the \acrshort{CPU}.

Correspondingly, the place labeled \Rustinline{PROGRAM_END} models
the end state of the program after normal program termination,
i.e., returning from the \Rustinline{main} function,
regardless of the specific exit code.
In other words, a main function that returns an error code because of invalid parameters
or an internal program error is still considered a ``normal'' program termination.
In other instances, however, the program may never reach this state
if \Rustinline{main} never returns.
These are known in Rust as ``diverging functions''\footnote{\url{https://doc.rust-lang.org/rust-by-example/fn/diverging.html}}
and are supported by the tool.

Lastly, the place labeled \Rustinline{PROGRAM_PANIC} models
the \emph{abnormal} program termination,
which happens when the program calls the \Rustinline{panic!()} macro.

\begin{figure}[!htb]
  \centering
  \includesvg{program-places.svg}
  \caption{Basic places in every Rust program}
  \label{fig:program-places}
\end{figure}

Two reasons for considering a separate panic end-state place can be argued.
First, it is helpful for formal verification to distinguish the panic case
from the normal termination case.
A program may panic when detecting a possible violation of its memory safety guarantees.
This is in most circumstances a wiser choice than simply ignoring the error and continuing.
Therefore, such programs should not be flagged in principle as erroneous or defective but
it is advisable to record the end state for troubleshooting and debugging purposes.
Second, even if the user's code does not resort to \Rustinline{panic!()}
as an error-handling mechanism, numerous functions in the Rust standard library
may panic under extraordinary circumstances, e.g., due to out-of-memory or hardware errors,
or when the \acrshort{OS} fails to allocate a new thread, mutex, etc.
Consequently, it is essential to capture this eventual failure in the \acrshort{PN} model.

There is one last subtle point that needs to be addressed.
The program's start place is not as trivial as it seems.
Although the \Rustinline{main} function is typically perceived
as the first function to be executed,
this is in reality not the case.
Instead, Rust programs have a runtime that executes
before the \Rustinline{main} function is called,
in which language-specific features and static memory are initialized.
One usually hears of interpreted languages such as Java or Python having a runtime
but low-level languages such as Rust or C have a small runtime as well.
It is simply thinner and less sophisticated.
For interested readers, a guided tour of the journey before \Rustinline{main}
was presented recently at a Rust conference \cite{levick2022}.

Considering this, we are faced with the question of
whether to include this runtime in the \acrshort{PN} translation.
On one hand, the runtime code is indeed part of the binary executed by the \acrshort{CPU}.
Nonetheless, it is platform-dependent code
(the runtime is slightly different for every \acrshort{OS})
and independent of the program's semantics,
i.e., of the specific meaning of the program the user wrote.
Since the user does not have any influence on this part of the binary,
synchronization problems cannot be attributed to him/her.
As such, this code does not add value to the translation
and can be safely abstracted away,
reducing in the process the size of the \acrshort{PN}.
In conclusion, the decision is to skip the runtime code;
the translation starts at the \Rustinline{main} function.

\subsection{Argument passing and entering the query}

The tool is designed around a simple \acrfull{CLI}.
After parsing the command-line arguments using the well-known
library \texttt{clap} library\footnote{\url{https://docs.rs/clap/latest/clap/}},
the program enters a query to the \emph{rustc} compiler
to start the translation process.
The majority of the work from that point on is coordinated
by the struct of type \texttt{Translator}\footnote{\url{https://github.com/hlisdero/cargo-check-deadlock/blob/main/src/translator.rs}}.

The query system was described briefly in Sec. \ref{sec:rustc}.
Two examples of the use of this mechanism are provided in the
documentation\footnote{\url{https://rustc-dev-guide.rust-lang.org/rustc-driver-interacting-with-the-ast.html}}\footnote{\url{https://rustc-dev-guide.rust-lang.org/rustc-driver-getting-diagnostics.html}}.
They have proved extremely useful as a starting point,
since they provide an excellent short working example of
how to interact with \emph{rustc}.
In simpler terms, they are the ``Hello, World!''
of working side-by-side with the Rust compiler.

\subsection{Compilation requirements}

As briefly mentioned in Sec. \ref{sec:rust-nightly}, the tool must be compiled
with the nightly version of \emph{rustc} to access its internal crates and modules.
The decisive section in the file
\emph{lib.rs}\footnote{\url{https://github.com/hlisdero/cargo-check-deadlock/blob/main/src/lib.rs}} is
depicted in Listing \ref{lst:use-rustc-crates}.

\begin{listing}[!htb]
  \begin{minted}[firstnumber=13]{Rust}
    // This feature gate is necessary to access the internal crates of the compiler.
    // It has existed for a long time and since the compiler internals will never be stabilized,
    // the situation will probably stay like this.
    // <https://doc.rust-lang.org/unstable-book/language-features/rustc-private.html>
    #![feature(rustc_private)]
    
    // Compiler crates need to be imported in this way because they are not published on crates.io.
    // These crates are only available when using the nightly toolchain.
    // It suffices to declare them once to use their types and methods in the whole crate.
    extern crate rustc_ast_pretty;
    extern crate rustc_const_eval;
    extern crate rustc_driver;
    extern crate rustc_error_codes;
    extern crate rustc_errors;
    extern crate rustc_hash;
    extern crate rustc_hir;
    extern crate rustc_interface;
    extern crate rustc_middle;
    extern crate rustc_session;
    extern crate rustc_span;
  \end{minted}
  \caption{Excerpt of the file \emph{lib.rs} showcasing how to use the \emph{rustc} internals.}
  \label{lst:use-rustc-crates}
\end{listing}

The \Rustinline{rustc_private} is a feature flag
that controls access to the compiler's private crates.
These crates are not installed by default when installing the Rust toolchain
using \emph{rustup}\footnote{\url{https://rustup.rs/}}.
Hence, it is necessary to install the additional components \emph{rustc-dev},
\emph{rust-src}, and \emph{llvm-tools-preview}.
The purpose of each component is detailed in \cite{rustup-book}.
Straightforward instructions to set up a development environment are also found
in the \texttt{README}\footnote{\url{https://github.com/hlisdero/cargo-check-deadlock/blob/main/README.md}}
of the repository.

To the best knowledge of this author,
an alternative method of accessing the internals of the Rust compiler does not exist.
Tools such as
Clippy\footnote{\url{https://github.com/rust-lang/rust-clippy/blob/master/rust-toolchain}} or
Kani \footnote{\url{https://github.com/model-checking/kani/blob/main/rust-toolchain.toml}}, or
kernels like Redox\footnote{\url{https://gitlab.redox-os.org/redox-os/redox/-/blob/master/rust-toolchain.toml}} and
RustyHermit\footnote{\url{https://github.com/hermitcore/rusty-hermit/blob/master/rust-toolchain.toml}}
use this mechanism as well.