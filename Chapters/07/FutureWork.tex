\section{Translated function cache}
\label{sec:future-work-function-cache}

A cache that stores functions after translating them is
an interesting optimization to explore.
The goal is to avoid redundant translations of the same function
when it is called multiple times within the program.
This idea was already briefly mentioned (but not implemented) in \cite{meyer2020}.
The current implementation does not incorporate such caching mechanisms.

This cache would have to store a separate \acrshort{PN} for each function.
It could be realized as a \Rustinline{HashMap<rustc_hir::def_id::DefId, PetriNet>},
analogous to the function counter already present in the implementation.
Furthermore, the translation process would need to merge/connect
the Petri nets resulting from each translated function.
This merging step requires support from the \acrshort{PN} library \texttt{netcrab}
to combine the multiple subnets into a cohesive whole.

However, connecting the individual Petri nets is not a trivial task,
as a function may call an arbitrary number of other functions.
Consequently, determining the appropriate ``contact points''
where the subnet should be connected becomes a challenging endeavor.
The potential existence of numerous contact points,
arising from the varying function call patterns, thus complicates the merging process.

Additionally, the Petri nets for each function should have labels that are unequivocal
across the whole program or at least when exporting them to the format for the model checker.
This requires generating slightly different versions of the same function for every call,
which partly neglects the benefits of having a cache in the first place.

Lastly, some functions may not be cached at all in the case that special side effects exist.
This happens for instance for all synchronization primitives currently supported.
Their translation must be handled individually.

\section{Recursion}
\label{sec:future-work-recursion}

Recursion in function calls poses a challenge in \acrshort{PN}
as defined in Sec. \ref{sec:petri-net-definition} due to the inability
to properly map the data values to the model.
\acrshort{PN} lack the necessary expressive power to represent this compactly.

The number of times a recursive function is called ultimately depends
on the data it is called with and cannot be determined at compile time.
In normal program execution,
a recursive function is pushed onto a new stack frame repeatedly
until the base case is reached or the stack overflows.
However, in \acrshort{PN}, the function call where the base case is reached
cannot be distinguished from the others,
unless somehow the tokens representing recursion levels are distinct.

\cite[Sec. 3.4.2]{meyer2020} discusses this problem
and proposes using high-level Petri nets, i.e. \acrfull{CPN} to solve it.
High-level Petri nets provide a possible solution by allowing the distinction
between tokens and the annotation of tokens with corresponding recursion levels.
Nevertheless, this necessitates a serious reconsideration of the entire translation logic
owing to the different formalism.
When using \acrshort{CPN} each transition becomes a generalized function of
input tokens of a specific type that generates tokens of the same or a different type.
The resulting Petri net is substantially more complex
and not all model checkers support \acrshort{CPN}.

Mitigation strategies provide no comfort in this case either.
On one hand, one could try to detect recursion and stop the translation,
but recursion may exhibit unusual patterns that are not trivial to detect.
For instance, consider a function A that calls a function B
that calls a function C which finally calls A again.
This recursion cycle may be arbitrarily long
and adding this capability to the translator
does not add much value compared to
simply ignoring the problem and reaching a stack overflow.

On the other hand, \cite{meyer2020} suggests
modeling each recursion level up to a maximum fixed depth,
but this would impact verification results,
as the properties of programs could vary with different maximum recursion depths.
For every maximum recursion depth $N$, a counterexample program can be constructed that exhibits
a different behavior, e.g. a deadlock, at recursion depth $N+1$, hence avoiding detection.