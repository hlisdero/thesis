% !TeX root = ../../Thesis.tex
\documentclass[../../Thesis.tex]{subfiles}
\graphicspath{{\subfix{../../images/}}}

\begin{document}

In this chapter, the literature on formal verification of Rust code
and Petri net modeling for deadlock detection is briefly reviewed.
Some of these previous publications contain approaches
that have guided this work.

In the next two sections, we will look at the existing tools,
their scope and their goals compared to the tool developed in this thesis.

Finally, a survey of the existing Petri net libraries in the Rust ecosystem
as of early 2023 is provided to justify the need to implement a library
from the ground up.

\section{Formal verification of Rust code}

There are numerous automatic verification tools available for Rust code.
A recommended first approximation to the topic is
the survey produced by Alastair Reid, a researcher at Intel.
It explicitly lists that most formal verification tools
do not support concurrency \cite{reid2021}.

The \emph{Miri}\footnote{\url{https://github.com/rust-lang/miri}} interpreter
developed by the Rust project on GitHub is an experimental interpreter
for the intermediate representation of the Rust language
(Mid-level Intermediate Representation, commonly known as ``\acrshort{MIR}'')
that allows executing standard cargo project binaries
in a granularized way, instruction by instruction,
to check for the absence of \acrfull{UB}
and other errors in memory handling.
It detects memory leaks, unaligned memory accesses, data races,
and precondition or invariant violations in code marked as \texttt{unsafe}.

\cite{toman2015crust} introduces a formal checker for Rust
that does not require modifications to the source code.
It was tested on past versions of modules from the Rust standard library.
As a result, errors were detected in the use of memory in unsafe Rust code
which in reality took months to be discovered manually by the development team.
This exemplifies the importance of using automatic verification tools
to complement manual code reviews.

\section{Deadlock detection using Petri nets}

Deadlock prevention is one of the classic strategies
to address this crucial problem in concurrent programming,
as discussed in Sec. \ref{sec:deadlock-strategies}.
The main problem with the approach of detecting deadlocks before they occur
is proving that the desired type of deadlock is detected in all cases
and that no false negatives are produced in the process.
The Petri net-based approach, being a formal method, satisfies these conditions.
However, the difficulty of adoption lies mainly in the practicability of the solution
due to the large number of possible states in a real software project.

In \cite{karatkevich2014deadlock}, a method is proposed
to reduce the number of explored states
during the detection of deadlocks using reachability analysis.
These heuristics help improve the performance of the Petri net-based approach.
Another optimization is presented in \cite{kungas2005petri}.
The author proposes a very promising polynomial order method to avoid the problem
of the state explosion that underlies the na√Øve deadlock detection algorithm.
Through an algorithm that abstracts a given Petri net to a simpler representation,
a hierarchy of networks of increasing size is obtained
for which the verification of the absence of deadlocks is substantially faster.
It is, crudely put, a ``divide and conquer'' strategy
that checks for the absence of deadlocks in parts of the network
to later build the verification of the final whole
by adding parts to the initial small network.

Despite the previously mentioned caveats,
the use of Petri nets as a formal software verification method
has been established since the late 1980s.
Petri nets allow for intuitive modeling of synchronization primitives,
such as sending a message or waiting for the reception of a message.
Examples of these simple nets with correspondingly simple behavior
are found in \cite{heiner1992petri}.
These nets are construction blocks that can be combined to form a more complex system.

To put these models to use, there are two possibilities:

\begin{itemize}
    \item One is designing the system in terms of Petri nets
          and then translating the Petri nets to the source code.
    \item The other one is to translate the existing source code to a Petri net representation
          and then verify that the Petri net model satisfies the desired properties.
\end{itemize}

For the purposes of this work, we are interested in the latter.
This approach is not novel.
It has been implemented for other programming languages like C and Rust already,
as seen in the literature.

In \cite{kavi2002modeling} and \cite{moshtaghi2001},
a translation of some synchronization primitives available as part of
the POSIX library of threads (\texttt{pthread}) in C to Petri nets is described.
In particular, the translation supports:

\begin{itemize}
    \item The creation of threads with the function \texttt{pthread\_create}
          and the handling of the variable of type \texttt{pthread\_t}.
    \item The thread join operation with the \texttt{pthread\_join} function.
    \item The operation of acquiring a mutex with \texttt{pthread\_mutex\_lock}
          and its eventual manual release with \texttt{pthread\_mutex\_unlock}.
    \item The \texttt{pthread\_cond\_wait} and \texttt{pthread\_cond\_signal} functions
          for working with condition variables.
\end{itemize}

In his master's thesis, \cite{meyer2020} establishes
the bases for a Petri net semantic for the Rust programming language.
He focuses his efforts however on single-threaded code,
limiting himself to the detection of deadlocks caused by
executing the \texttt{lock} operation twice on the same mutex in the main thread.
Unfortunately, the code available on GitHub\footnote{\url{https://github.com/Skasselbard/Granite}}
as part of the thesis is no longer valid for the new version of \emph{rustc}
since the internals of the compiler changed significantly in the last three years.

In a late 2022 pre-print, \cite{zhang2022deadlocks} implement a translation
of Rust source code to Petri nets for checking deadlocks.
The translation focuses on deadlocks caused by two types of locks
in the standard library: \texttt{std::sync::Mutex} and \texttt{std::sync::RwLock}.
The resulting Petri net is expressed in the \acrfull{PNML}
and fed into the model checker \acrfull{PIPE2}\footnote{\url{https://pipe2.sourceforge.net/}}
to perform reachability analysis.
Function calls are handled in a very different way compared to this work and
missed signals are not modeled at all.
The source code of their tool, named TRustPN, is not publicly available as of this writing.
Despite these limitations, the authors offer a very detailed and up-to-date survey
of static analysis tools for checking Rust code,
which could be appealing to the interested reader.
Moreover, they list several papers dedicated to
formalizing the semantics of the Rust programming language,
which are out of the scope of this work.

\section{Petri nets libraries in Rust}

As part of the development of the translation of the source code to a Petri net,
it is necessary to use a Petri net library for the Rust programming language.
A quick search of the packages available on
\emph{crates.io}\footnote{\url{https://crates.io/}}, GitHub, and GitLab
revealed that there is, unfortunately, no well-maintained library.

Some Petri net simulators were found such as:

\begin{itemize}
    \item pns\footnote{\url{https://gitlab.com/porky11/pns}}:
          Programmed in C. It does not offer the option
          to export the resulting network to a standard format.
    \item PetriSim\footnote{\url{https://staff.um.edu.mt/jskl1/petrisim/index.html}}:
          An old DOS/PC simulator programmed in Bordland Pascal.
    \item WOLFGANG\footnote{\url{https://github.com/iig-uni-freiburg/WOLFGANG}}:
          A Petri net editor in Java, maintained by the Department of Computer Science
          at the University of Freiburg, Germany.
\end{itemize}

Regrettably, none of them meet the requirements of the task.

Since a Petri net is a graph, the possibility
of using a graph library and modifying it to suit the objectives of this work was considered.
Two graph libraries were found in Rust:

\begin{itemize}
    \item petgraph\footnote{\url{https://docs.rs/petgraph/latest/petgraph/}}:
          The most widely used library for graphs in \textit{crates.io}.
          It offers an option to export to the DOT format.
    \item gamma\footnote{\url{https://github.com/metamolecular/gamma}}:
          Unstable and unchanged since 2021. It does not offer the ability to export the graph.
\end{itemize}

None of the possibilities satisfies the requirement
to export the resulting network to the \acrshort{PNML} format.
In addition, if a graph library is used,
the operations of a Petri net should be implemented as a \emph{wrapper} around a graph,
which reduces the possibility of optimizations for our use case
and hinders the long-term extensibility of the project.

In conclusion, it is imperative
to implement a Petri net library in Rust from scratch as a separate project.
This contributes one more tool to the community that could be reused in the future.

\section{Exchange file formats for Petri nets}

As observed in the preceding chapter,
Petri nets are a widely used tool for modeling software systems.
However, due to the different classes of Petri nets
(simple Petri nets, high-level Petri nets, timed Petri nets,
stochastic Petri nets, colored Petri nets, to name a few),
designing a standardized exchange file format
compatible with all applications has proven challenging.
One reason for this is that
Petri nets can be implemented and represented in multiple ways,
depending on the specific objectives, given that they are a type of graph.

In order to guarantee a certain degree of interoperability between the tool developed
as part of this thesis and other existing and future tools, it is crucial
to investigate which file formats would be more convenient to support.
The aim is to support file formats that are suited to analysis as well as visualization,
allowing for the possibility of extension to additional formats in the future,
via a well-defined API in the Petri net library.
A literature review led to three relevant file formats that are presented next.

\subsection{Petri Net Markup Language}

The \acrfull{PNML}\footnote{\url{https://www.pnml.org/}}
is a standard file format designed
for the exchange of Petri nets
among different tools and software applications.
Its development was initiated
at the `Meeting on XML/SGML based Interchange Formats for Petri Nets'
held in Aarhus in June 2000 \cite{jungel2000petri},
with the goal of providing
a standardized and widely accepted format for Petri net models.
PNML is an ISO standard consisting, as of 2023, of three parts:

\begin{itemize}
    \item ISO/IEC 15909-1:2004\footnote{\url{https://www.iso.org/standard/38225.html}}
          (and its latest revision ISO/IEC 15909-1:2019\footnote{\url{https://www.iso.org/standard/67235.html}})
          for concepts, definitions, and graphical notation.
    \item ISO/IEC 15909-2:2011\footnote{\url{https://www.iso.org/standard/43538.html}}
          for defining a transfer format based on XML.
    \item ISO/IEC 15909-3:2021\footnote{\url{https://www.iso.org/standard/81504.html}}
          for the extensions and structuring mechanisms.
\end{itemize}

It has become a de-facto standard
for exchanging Petri net models across different tools and systems.
It resulted from many years of hard work
to unify the notation as discussed in \cite{hillah:hal-01176335}.

\acrshort{PNML} has been designed to be a flexible and extensible format
that can represent different classes of Petri nets,
including simple Petri nets and high-level Petri nets.
It is based on the \acrfull{XML}
which makes it easy to read and parse by humans and machines alike.
Additionally, \acrshort{PNML} supports the use of metadata
to provide additional information about the Petri net models,
such as authorship, date of creation, and licensing information.

The development of \acrshort{PNML} has significantly improved
the interoperability and exchange of Petri net models
among different tools and systems.
Before the adoption of \acrshort{PNML},
exchanging Petri net models was a challenging task,
as different tools used proprietary formats
that were often incompatible with each other.
\acrshort{PNML} has greatly simplified this process,
enabling researchers and practitioners
to share and collaborate on Petri net models with ease.
Its use has also facilitated the development of new tools
and software applications for Petri nets,
as it provides a standard format
that can be easily parsed and processed by different systems.
For instance, it is the format used
in \cite{zhang2022deadlocks} and it is supported in \cite{meyer2020}.

\subsection{GraphViz DOT format}

The DOT format is a graph description language
used for creating visual representations of graphs and networks,
which is part of the open-source GraphViz suite\footnote{\url{https://graphviz.org/}}.
It was created in the early 1990s at AT\&T Labs Research
as a simple, concise, and human-readable language for describing graphs.
The GraphViz suite provides several tools for working with DOT files,
including the ability to automatically generate layouts for complex graphs and
to export visualizations in a range of formats, including PNG, PDF, and SVG.

DOT can be used to represent Petri nets in a graphical format, which makes it easy
to visualize the structure and behavior of the system being modeled.
It is particularly useful for visualizing large Petri nets,
as the user can navigate through the image
to gain an understanding of how the tokens flow through the net.

The DOT format is text-based and easy to use,
making it a popular choice for generating visual representations of graphs.
This simplicity also means that DOT files can be easily generated by programs
and can be read by a wide range of software tools,
which is essential for interoperability.
Additionally, DOT allows for the specification of various graph properties,
such as node shapes, colors, and styles \cite{dot2015},
which can be used to represent different aspects of a Petri net,
such as places, transitions, and arcs.
This flexibility in specifying visual properties also enables users
to customize the visualization to their needs and
to highlight particular features of the Petri net
that are important for their analysis.

\subsection{LoLA - Low Level Petri Net Analyzer}

\acrfull{LoLA} is a state-of-the-art model checker
developed at the University of Rostock in
Germany\footnote{\url{https://theo.informatik.uni-rostock.de/theo-forschung/tools/lola/}}
and published under the GNU Affero General Public License.
\acrshort{LoLA} is a tool that can check
if a system satisfies a given property expressed in \acrfull{CTL*}.
Its particular strength is the evaluation of simple properties
such as deadlock freedom or reachability as stated on the website.

This is the model checker used in \cite{meyer2020} and in this work.
Therefore, it is necessary to implement the file format required by the tool.
Examples will be presented in Chapter \ref{chap:implementation}.

\end{document}