% !TeX root = ../Thesis.tex
\documentclass[../Thesis.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}

\begin{document}

In this chapter, the literature on formal verification of Rust code
and Petri net modeling for deadlock detection is briefly reviewed.
Some of these previous publications contain approaches
that have guided this work.

In the next two sections, we will look at the existing tools,
their scope and their goals compared to the tool developed in this thesis.

Finally, a survey of the existing Petri net libraries in the Rust ecosystem
as of early 2023 is provided to justify the need to implement a library
from the ground up.

\section{Formal verification of Rust code}

There are numerous automatic verification tools available for Rust code.
A recommended first approximation to the topic is
the survey produced by Alastair Reid, a researcher at Intel.
It explicitly lists that most formal verification tools
do not support concurrency \cite{reid2021}.

The \emph{Miri}\footnote{\url{https://github.com/rust-lang/miri}} interpreter
developed by the Rust project on GitHub is an experimental interpreter
for the intermediate representation of the Rust language
(Mid-level Intermediate Representation, commonly known as "MIR")
that allows executing standard cargo project binaries
in a granularized way, instruction by instruction,
to check for the absence of \acrfull{UB}
and other errors in memory handling.
It detects memory leaks, unaligned memory accesses, data races,
and precondition or invariant violations in code marked as \texttt{unsafe}.

\cite{toman2015crust} introduces a formal checker for Rust
that does not require modifications to the source code.
It was tested on past versions of modules from the Rust standard library.
As a result, errors were detected in the use of memory in unsafe Rust code
which in reality took months to be discovered manually by the development team.
This exemplifies the importance of using automatic verification tools
to complement manual code reviews.

\section{Deadlock detection using Petri nets}

Deadlock prevention is one of the classic strategies
to address this crucial problem in concurrent programming,
as discussed in Sec. \ref{sec:deadlock-strategies}.
The main problem with the approach of detecting deadlocks before they occur
is proving that the desired type of deadlock is detected in all cases
and that no false negatives are produced in the process.
The Petri net-based approach, being a formal method, satisfies these conditions.
However, the difficulty of adoption lies mainly in the practicability of the solution
due to the large number of possible states in a real software project.

In \cite{karatkevich2014deadlock}, a method is proposed
to reduce the number of explored states
during the detection of deadlocks using reachability analysis.
These heuristics help improve the performance of the Petri net-based approach.
Another optimization is presented in \cite{kungas2005petri}.
The author proposes a very promising polynomial order method to avoid the problem
of the state explosion that underlies the na√Øve deadlock detection algorithm.
Through an algorithm that abstracts a given Petri net to a simpler representation,
a hierarchy of networks of increasing size is obtained
for which the verification of the absence of deadlocks is substantially faster.
It is, crudely put, a ``divide and conquer'' strategy
that checks for the absence of deadlocks in parts of the network
to later build the verification of the final whole
by adding parts to the initial small network.

Despite the previously mentioned caveats,
the use of Petri nets as a formal software verification method
has been established since the late 1980s.
Petri nets allow for intuitive modeling of synchronization primitives,
such as sending a message or waiting for the reception of a message.
Examples of these simple nets with correspondingly simple behavior
are found in \cite{heiner1992petri}.
These nets are construction blocks that can be combined to form a more complex system.

To put these models to use, there are two possibilities:

\begin{itemize}
    \item One is designing the system in terms of Petri nets
          and then translating the Petri nets to the source code.
    \item The other one is to translate the existing source code to a Petri net representation
          and then verify that the Petri net model satisfies the desired properties.
\end{itemize}

For the purposes of this work, we are interested in the latter.
This approach is not novel.
It has been implemented for other programming languages like C and Rust already,
as seen in the literature.

In \cite{kavi2002modeling} and \cite{moshtaghi2001},
a translation of some synchronization primitives available as part of
the POSIX library of threads (\texttt{pthread}) in C to Petri nets is described.
In particular, the translation supports:

\begin{itemize}
    \item The creation of threads with the function \texttt{pthread\_create}
          and the handling of the variable of type \texttt{pthread\_t}.
    \item The thread join operation with the \texttt{pthread\_join} function.
    \item The operation of acquiring a mutex with \texttt{pthread\_mutex\_lock}
          and its eventual manual release with \texttt{pthread\_mutex\_unlock}.
    \item The \texttt{pthread\_cond\_wait} and \texttt{pthread\_cond\_signal} functions
          for working with condition variables.
\end{itemize}

In his master's thesis, \cite{meyer2020} establishes
the bases for a Petri net semantic for the Rust programming language.
He focuses his efforts however on single-threaded code,
limiting himself to the detection of deadlocks caused by
executing the \texttt{lock} operation twice on the same mutex in the main thread.
Unfortunately, the code available on GitHub\footnote{\url{https://github.com/Skasselbard/Granite}}
as part of the thesis is no longer valid for the new version of \emph{rustc}
since the internals of the compiler changed significantly in the last three years.

In a late 2022 pre-print, \cite{zhang2022deadlocks} implement a translation
of Rust source code to Petri nets for checking deadlocks.
The translation focuses on deadlocks caused by two types of locks
in the standard library: \texttt{std::sync::Mutex} and \texttt{std::sync::RwLock}.
The resulting Petri net is expressed in the \acrfull{PNML}
and fed into the model checker \acrfull{PIPE2}\footnote{\url{https://pipe2.sourceforge.net/}}
to perform reachability analysis.
Function calls are handled in a very different way compared to this work and
missed signals are not modeled at all.
The source code of their tool, named TRustPN, is not publicly available as of this writing.
Despite these limitations, the authors offer a very detailed and up-to-date survey
of static analysis tools for checking Rust code,
which could be appealing to the interested reader.
Moreover, they list several papers dedicated to
formalizing the semantics of the Rust programming language,
which are out of the scope of this work.

\section{Petri nets libraries in Rust}

As part of the development of the translation of the source code to a Petri net,
it is necessary to use a Petri net library for the Rust programming language.
A quick search of the packages available on
\emph{crates.io}\footnote{\url{https://crates.io/}}, GitHub, and GitLab
revealed that there is unfortunately no well-maintained library.

Some Petri net simulators were found such as:

\begin{itemize}
    \item pns\footnote{\url{https://gitlab.com/porky11/pns}}:
          Programmed in C. It does not offer the option
          to export the resulting network to a standard format.
    \item PetriSim\footnote{\url{https://staff.um.edu.mt/jskl1/petrisim/index.html}}:
          An old DOS/PC simulator programmed in Bordland Pascal.
    \item WOLFGANG\footnote{\url{https://github.com/iig-uni-freiburg/WOLFGANG}}:
          A Petri net editor in Java, maintained by the Department of Computer Science
          at the University of Freiburg, Germany.
\end{itemize}

Regrettably, none of them meet the requirements of the job.

Since a Petri net is a graph, the possibility
of using a graph library and modifying it to suit the objectives of this work was considered.
Two graph libraries were found in Rust:

\begin{itemize}
    \item petgraph\footnote{\url{https://docs.rs/petgraph/latest/petgraph/}}:
          The most widely used library for graphs in \textit{crates.io}.
          It offers an option to export to the DOT format.
    \item gamma\footnote{\url{https://github.com/metamolecular/gamma}}:
          Unstable and unchanged since 2021. It does not offer the ability to export the graph.
\end{itemize}

None of the possibilities satisfies the requirement
to export the resulting network to the PNML format.
In addition, if a graph library is used,
the operations of a Petri net should be implemented as a \emph{wrapper} around a graph,
which reduces the possibility of optimizations for our use case
and hinders the long-term extensibility of the project.

In conclusion, it is imperative
to implement a Petri net library in Rust from scratch as a separate project.
This contributes one more tool to the community that could be reused in the future.

\end{document}