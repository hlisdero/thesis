In order to fully understand the scope and context of this work,
it is important to provide some background topics
that lay the foundation for the research.
These background topics serve as the theoretical building blocks
upon which the translation is built.

First, the theory of Petri nets is presented
both graphically and in mathematical terms.
To illustrate the modeling power and versatility of Petri nets,
several different models are provided to the reader as examples.
These models showcase the ability of Petri nets
to capture various aspects of concurrent systems
and represent them in a visual and intuitive manner.
Later on, some important properties are introduced and the reachability analysis
performed by the model checker is explained.

Second, the Rust programming language and
its main characteristics are briefly discussed.
A handful of examples of noteworthy applications of Rust in the industry are included.
Compelling evidence for the use of memory-safe languages was gathered to argue
the case that Rust provides an excellent base
for extending the detection of classes of errors at compile time.

Third, a background
on the problem of deadlocks and missed signals when using condition variables is provided,
as well as a description of the common strategies used to address these issues.

Lastly, an overview of compiler architecture
and the concept of model checking is provided.
We will note the still untapped potential
that formal verification offers
to increase the safety and reliability of software systems.